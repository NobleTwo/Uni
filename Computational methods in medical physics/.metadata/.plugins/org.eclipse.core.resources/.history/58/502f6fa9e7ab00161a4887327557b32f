#include <cmath>
#include <random>
#include <cfloat>
#include <fstream>

//computes integral by sampling method
double simpleSampling(int numberOfSamples){
	//lower and upper boundary of interval
	int a=0;
	int b=1;

	//sum over all f(x); computed to <f(x)> in return statement
	double sum_f_x = 0;
	for(int i=0; i<numberOfSamples; i++){
		//get random number in x e [0,1] and compute f(x)
		double x = double(rand())/RAND_MAX;
		sum_f_x += exp(-pow(x,2));
	}

	//return integral
	return (b-a)*sum_f_x/numberOfSamples;
}

double importanceSampling(int numberOfSamples){
	double sum_f_x = 0;
	for(int i=0; i<numberOfSamples; i++){
		double y = rand();
		double x = g_1(x)
		sum_f_x +=
	}
}

int main(){
	srand(time(NULL));

	//new file
	std::ofstream file_simple;
	file_simple.open("values_sample.txt");

	//same for hit-or-miss
	std::ofstream file_importance;
	file_importance.open("values_hOm.txt");
	int runsForVariance = 100;

	//loop over numberOfSamples
	for(int i=0; i<6; i++){
		int numberOfSamples = pow(10,i);

		//initilaize mean, min and max value for both methods
		double simpleSampling_mean = 0;
		double simpleSampling_min = DBL_MAX;
		double simpleSampling_max = -DBL_MAX;

		double importanceSampling_mean = 0;
		double importanceSampling_min = DBL_MAX;
		double importanceSamling_max = -DBL_MAX;

		//loop over number of runs for variance
		for(int j=0; j<runsForVariance; j++){
			//compute integral by sampling method
			double simple = simpleSampling(numberOfSamples);

			//add to mean of sampling method (divided by runsForVariance for right result)
			simpleSampling_mean += simple;

			//compare with min and max value of hit-or-miss
			if(simple<simpleSampling_min){
				simpleSampling_min = simple;
			}
			if(simple>simpleSampling_max){
				simpleSampling_max = simple;
			}

			//compute integral by hir-or-miss-method
			double importance = hitOrMiss(numberOfSamples);

			//add to mean of hit-or-miss-method (divided by runsForVariance for right result)
			importanceSampling_mean += importance;

			//compare with min and max value of hit-or-miss
			if(importance<importanceSampling_min){
				importanceSampling_min = hOm;
			}
			if(hOm>hitOrMiss_max){
				importanceSampling_max = hOm;
			}
		}

		//print and write into file
		//in order for sample: numberOfSamples - integral sampling method - sampling method max - sampling method min
		//in order for hit-or-miss: numberOfSamples - integral hit-or-miss - hit or miss min - hit or miss max
		std::cout << numberOfSamples << "\t" << simpleSampling_mean/runsForVariance << "\t" << simpleSampling_max-simpleSampling_min << "\t";
		file_simple << numberOfSamples << "\t" << simpleSampling_mean/runsForVariance << "\t" << simpleSampling_min << "\t" << simpleSampling_max << std::endl;
		std::cout << importanceSampling_mean/runsForVariance << "\t" << importanceSampling_max-importanceSampling_min << "\t" << "0.326543" << std::endl;
		file_importance << numberOfSamples << "\t" << importanceSampling_mean/runsForVariance << "\t" << importanceSampling_min << "\t" << importanceSampling_max << std::endl;
	}
	file_simple.close();
}
